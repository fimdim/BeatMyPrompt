# BeatMyPrompt ğŸ¤
**Live AI Verse Battles Powered by Audience Claps**

> ğŸ¤– This project was fully generated by **GitHub Copilot** in **VS Code** â€” code, structure, and all.

![BeatMyPrompt Screenshot](resources/BeatMyPrompt-image.png)

### Demo Video

https://github.com/fimdim/BeatMyPrompt/raw/main/resources/BeatMyPrompt-video.mp4

## Elevator Pitch

**BeatMyPrompt** is a live AI battle experience where two AIâ€‘generated verses go headâ€‘toâ€‘head, and the **audience decides the winner using their applause**.

No apps, no signâ€‘ups, no friction.  
Just:
- AI for **creative generation**
- A crowd for **judgment**
- And a big, visual **Clapâ€‘Oâ€‘Meter** that turns noise into scores and declares the champion.

Designed for:
- Tech events & hackathons (e.g. Agents League, TechConnect)
- Creative / marketing meetups
- Any session where you want to show AI as a *performer*, not just a *productivity tool*.

---

## Technologies Used

| Category | Technology |
|---|---|
| **UI Framework** | React 19 + TypeScript |
| **Bundler** | Vite 7 |
| **AI Backend** | GitHub Models API (OpenAI-compatible `/chat/completions` endpoint, authenticated with a GitHub PAT) |
| **Audio Input** | Web Audio API (`AnalyserNode` + `getUserMedia`) â€” real-time mic RMS for the Clap-O-Meter |
| **Text-to-Speech** | Web Speech API (`SpeechSynthesisUtterance`) |
| **Visual Effects** | `canvas-confetti` for winner celebrations; CSS animations for overdrive, countdown, score bars |

> Fully client-side â€” no backend server required.

### Technical Highlights

The entire app runs **zero-backend** â€” verse generation, text-to-speech, and live audio analysis all happen in the browser, making setup as simple as `npm run dev` with a single env variable. Both verses are generated in **parallel** against independent LLM models via `Promise.all`, so even cross-model battles (e.g. GPT-4o vs DeepSeek R1) resolve in roughly the time of one call. The Clap-O-Meter computes **real-time RMS volume** from raw `Float32Array` mic samples at 60 fps via `requestAnimationFrame`, with a weighted scoring formula (60 % average + 40 % peak) that rewards both sustained energy and big spikes â€” and the whole battle flow is driven by a clean **finite state machine** (`setup â†’ generating â†’ showVerses â†’ clapA â†’ clapB â†’ result`) that keeps the component logic readable despite the many interactive phases.

### Quick Setup

```bash
git clone https://github.com/fimdim/BeatMyPrompt.git
cd BeatMyPrompt
npm install
echo "VITE_GITHUB_TOKEN=your_github_pat_here" > .env   # replace with your GitHub PAT (models:read scope)
npm run dev
```

Open `http://localhost:5173`, allow microphone access, and you're ready to battle.

| Command           | Description                          |
| ----------------- | ------------------------------------ |
| `npm run dev`     | Start the Vite dev server            |
| `npm run build`   | Typeâ€‘check and build for production  |
| `npm run preview` | Preview the production build locally |

---

## Concept

BeatMyPrompt combines:
- **Multiple large language models** â€” the host picks a different model for each verse, pitting AI against AI.
- A **live audio "Clapâ€‘Oâ€‘Meter"** using the laptop's microphone to measure audience applause.
- **Textâ€‘toâ€‘speech** so verses can be read aloud automatically via the browser.
- A **stageâ€‘friendly UI** that shows verses, clap intensity and the final winner.

Each round:
1. The host enters a **topic** and selects a **style** (e.g. rap battle, slam poetry, Shakespeare, corporate jargon, "French existentialist", etc.).
2. The host chooses an **AI model for Verse A** and an **AI model for Verse B** (e.g. GPTâ€‘4o vs DeepSeek R1).
3. The app generates **Verse A** and **Verse B** with distinct personas â€” each from its own model, in parallel.
4. Verses can be **read aloud** individually or sequentially using builtâ€‘in textâ€‘toâ€‘speech.
5. After each performance, the audience claps, and the Clapâ€‘Oâ€‘Meter measures how loud and energetic the room is.
6. The app compares the **Clap Power** scores for Verse A vs Verse B and declares the winner with an onâ€‘screen celebration.

---

## Why This Idea?

Modern AI demos often:
- Show code completion,
- Answer questions in chat,
- Or generate static content.

Thatâ€™s cool, but not always **memorable** in a live arena.

BeatMyPrompt:
- Turns an AI demo into a **participatory show**.
- Makes prompt engineering fun and visible (topics, styles, personas, chaos constraints).
- Puts **humans in control** as judges: the AI generates, but the crowd decides.

Itâ€™s a playful but powerful way to:
- Explore AI as a **creative collaborator**,
- Demonstrate **humanâ€‘inâ€‘theâ€‘loop** decision making,
- Spark conversations around AI in creativity, marketing, dev culture, etc.

---

## How It Works (Highâ€‘Level)

### 1. Host Setup

On the host screen (projected to the audience):

1. Enter a **topic**  
   Examples:
   - â€œAgents League & GitHub Copilotâ€
   - â€œCloud vs Onâ€‘Premâ€
   - â€œDeveloper vs Project Managerâ€
   - â€œAgency vs Clientâ€

2. Choose a **style** from a dropdown  
   - Rap Battle  
   - Slam Poetry  
   - Shakespearean Monologue  
   - Corporate Buzzword Mode  
   - French Existentialist  
   - (Extensible with more presets)

3. Optional: toggle **Chaos Mode**  
   - Adds random creative constraints:
     - â€œInclude a cooking metaphorâ€
     - â€œExplain it as if to a medieval kingâ€
     - â€œEvery line must reference the cloudâ€, etc.

4. Click **Generate Battle**  
   - The app asks the AI to generate:
     - **Verse A** (Persona 1 â€“ e.g., serious technical expert)
     - **Verse B** (Persona 2 â€“ e.g., chaotic meme lord)

Verses are displayed sideâ€‘byâ€‘side on the big screen.

---

### 2. Performance & Clap Voting

Each round follows a simple flow:

#### Step 1 â€“ Perform Verse A

- The host clicks **ğŸ”Š Read Aloud** on Verse A's card to have the browser read it via textâ€‘toâ€‘speech, or reads it manually.
- Alternatively, the host clicks **ğŸ”Š Read Both Aloud** to have A then B performed sequentially.
- After the performance, the host says:  
  > â€œIf you want Verse A to win, make some noise when the meter starts!â€

- On screen:
  - Big text: **â€œClap for Verse A inâ€¦â€**
  - Countdown: **3â€¦ 2â€¦ 1â€¦**

- The **Clapâ€‘Oâ€‘Meter** activates:
  - Uses the laptopâ€™s microphone.
  - Listens for a short window (e.g. 3 seconds).
  - Visualizes audience noise in real time with a colorful gauge or bar.
  - Captures a **Clap Power** score (e.g. `76 / 100`).

#### Step 2 â€“ Perform Verse B

- Same flow:
  - Perform **Verse B**.
  - Run the Clapâ€‘Oâ€‘Meter with a countdown.
  - The gauge reacts to the claps and locks in a score (e.g. `89 / 100`).

---

### 3. Winner Reveal

After both clap rounds:

- The screen shows **both scores sideâ€‘byâ€‘side**:
  - Verse A: blue bar + score.
  - Verse B: red bar + score.

- The higher score is visually highlighted:
  - Confetti / particles.
  - Color halo around the winner.
  - Large label: **â€œWINNER: VERSE B!â€**

- Optional: the AI acts as an announcer and generates a oneâ€‘line recap:
  - â€œVerse B obliterated Verse A like legacy code in a greenfield refactor.â€
  - â€œVerse A had the bars, Verse B had the heart â€“ the audience chose heart!â€

---

## Core Features (MVP)

**Host View**
- Topic input.
- Style selection (rap, slam, Shakespeare, corporate, etc.).
- **Model selection** for Verse A and Verse B (independent dropdowns).
- Chaos Mode toggle.
- Generate Verse A & Verse B (parallel calls to selected models).
- **Read Aloud** per verse (ğŸ”Š button) or **Read Both Aloud** sequentially.
- Buttons:
  - **Start Clap for Verse A**
  - **Start Clap for Verse B**
  - **Show Winner / Next Battle**
- **Soundcheck** button to test the Clapâ€‘Oâ€‘Meter before a battle.

**Audience Interaction**
- No devices required.
- Engagement via:
  - Listening to the verses.
  - Clapping to vote.
  - Watching the Clapâ€‘Oâ€‘Meter react in real time.

**Clapâ€‘Oâ€‘Meter**
- Uses laptop mic audio volume to estimate crowd intensity.
- Animated gauge or bar chart:
  - Live animation during the clap window.
  - Freezes at a max â€œClap Powerâ€ score at the end.
- Compares A vs B to determine the winner.

---

## Optional Enhancements (Stretch Ideas)

- **Persona Presets**
  - â€œDev vs PMâ€
  - â€œCloud vs Onâ€‘Premâ€
  - â€œCopilot vs Manual Coderâ€
  - â€œAgency vs Clientâ€
  - Each preset defines different tones, vocabularies, and attitudes for Verse A and B.

- **Bestâ€‘ofâ€‘3 Categories**
  - Run three clap rounds per battle:
    1. Flow / Rhythm
    2. Humor / Punchlines
    3. Relevance to Topic
  - Show which verse wins each category and the overall result.

- **Overdrive Zone**
  - If claps are extremely loud, the meter enters a special â€œOverdriveâ€ state:
    - Flashing colors, fire, lightning, etc.
    - Onâ€‘screen message like: â€œAUDIENCE OVERDRIVE! Verse A broke the meter!â€

- **Awkwardly Quiet Handling**
  - If clap intensity is too low:
    - Show a playful message:
      - â€œSystem thinks youâ€™re on mute â€“ letâ€™s try that again louder!â€
    - Allows a reâ€‘run of the clap for that verse.

- **Battle History**
  - Short log of previous topics, styles, winners and scores.
  - Useful for endâ€‘ofâ€‘session recap.

---

## Example Live Session Flow

**1. Intro (30â€“60s)**  
> â€œWelcome to BeatMyPrompt â€“ an AI verse battle. I give the topic and style, the AI writes the verses, and *you* decide the winner by clapping. The louder you clap, the higher the score on our Clapâ€‘Oâ€‘Meter.â€

**2. Warmâ€‘Up Clap**  
- Run a â€œsoundcheckâ€ clap so the audience sees how their noise affects the meter.

**3. Battle 1 â€“ On Theme**  
- Topic: â€œAgents League & GitHub Copilotâ€.
- Style: Rap Battle.
- Generate + perform Verse A & B.
- Clapâ€‘Oâ€‘Meter voting.
- Reveal winner + AI announcer line.

**4. Battle 2 â€“ Audience Chaos**  
- Ask the audience for a random topic and style.
- Turn on Chaos Mode.
- Repeat the battle flow.

**5. Battle 3 â€“ Final Showdown**  
- Topic tied closely to the audience (e.g., cloud vs onâ€‘prem, agencies, internal culture).
- Optionally use Bestâ€‘ofâ€‘3 categories.
- Big final winner reveal.

**6. Wrapâ€‘Up**  
- Connect the experience back to:
  - AI as a creative partner.
  - Humanâ€‘inâ€‘theâ€‘loop decision making (applause as a â€œvoteâ€).
  - Potential uses for creativity, marketing, ideation, and developer culture.

---

## Summary

BeatMyPrompt transforms AI content generation into a **live, interactive battle** where:
- LLMs generate creative verses in a variety of voices.
- The audience becomes the jury using pure human energy.
- A visual Clapâ€‘Oâ€‘Meter makes the roomâ€™s reaction visible and fun.

Itâ€™s a highâ€‘energy, lowâ€‘friction way to:
- Showcase AI,
- Engage a crowd,
- And make your event **unforgettable**.

---

## Running Locally

### Prerequisites

- [Node.js](https://nodejs.org/) v18 or later
- A **GitHub Personal Access Token** with the `models:read` scope (for the GitHub Models API)

### Setup

1. **Clone the repository**

   ```bash
   git clone https://github.com/fimdim/BeatMyPrompt.git
   cd BeatMyPrompt
   ```

2. **Install dependencies**

   ```bash
   npm install
   ```

3. **Create a `.env` file** in the project root with your GitHub token:

   ```
   VITE_GITHUB_TOKEN=your_github_pat_here
   ```

4. **Start the development server**

   ```bash
   npm run dev
   ```

   The app will be available at `http://localhost:5173/` (or the next available port).

5. **Allow microphone access** when prompted â€” this is required for the Clapâ€‘Oâ€‘Meter.

### Other Commands

| Command           | Description                          |
| ----------------- | ------------------------------------ |
| `npm run dev`     | Start the Vite dev server            |
| `npm run build`   | Typeâ€‘check and build for production  |
| `npm run preview` | Preview the production build locally |

---

## Technical Implementation

**Stack:**  React + Vite + TypeScript (singleâ€‘page clientâ€‘side app)

**AI Backend:**  GitHub Models API (`https://models.github.ai/inference/chat/completions`) â€” OpenAIâ€‘compatible, authenticated with a GitHub PAT (`models:read` scope). No server needed; the token lives in a `.env` file.

**Audio:**  Web Audio API (`AnalyserNode` + `getUserMedia`) for realâ€‘time RMS volume measurement. Scoring uses weighted average (60% avg + 40% peak) over a 5â€‘second clap window.

**Textâ€‘toâ€‘Speech:**  Web Speech API (`SpeechSynthesisUtterance`) for reading verses aloud.

**Visuals:**  `canvasâ€‘confetti` for winner celebration. CSS animations for overdrive shake, countdown pop, and score bar growth.

### Project Structure

```
beat-my-prompt/
â”œâ”€â”€ index.html
â”œâ”€â”€ vite.config.ts
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ package.json
â”œâ”€â”€ .env                          # VITE_GITHUB_TOKEN
â”œâ”€â”€ public/
â”‚   â””â”€â”€ favicon.svg
â””â”€â”€ src/
    â”œâ”€â”€ main.tsx
    â”œâ”€â”€ App.tsx
    â”œâ”€â”€ index.css                  # Stageâ€‘ready dark theme
    â”œâ”€â”€ types/
    â”‚   â””â”€â”€ index.ts               # Style, ModelId, BattleConfig, Verse, ClapScore, etc.
    â”œâ”€â”€ data/
    â”‚   â””â”€â”€ chaosConstraints.ts    # 20 random creative constraints
    â”œâ”€â”€ services/
    â”‚   â””â”€â”€ ai.ts                  # generateBattle(), generateAnnouncerLine()
    â”œâ”€â”€ hooks/
    â”‚   â”œâ”€â”€ useAudioMeter.ts       # Mic access + RMS volume (0â€‘100)
    â”‚   â””â”€â”€ useSpeech.ts           # Textâ€‘toâ€‘speech wrapper
    â””â”€â”€ components/
        â”œâ”€â”€ SetupForm.tsx          # Topic, style, model selectors, chaos toggle
        â”œâ”€â”€ VerseCard.tsx          # Verse display + model badge + read aloud button
        â”œâ”€â”€ Countdown.tsx          # 3â€¦ 2â€¦ 1â€¦ GO animation
        â”œâ”€â”€ ClapMeter.tsx          # Live audio gauge + overdrive / quiet detection
        â”œâ”€â”€ ScoreReveal.tsx        # Animated score bars + confetti + announcer line
        â””â”€â”€ BattleScreen.tsx       # State machine: setup â†’ generating â†’ show â†’ clap â†’ result
```